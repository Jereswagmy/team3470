package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.CRServo;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;

import static org.firstinspires.ftc.robotcore.internal.opmode.OnBotJavaManager.initialize;

@TeleOp(name = "Scratch")


public class Scratch extends LinearOpMode {

    private DcMotor rightMotor, leftMotor, frontLeftMotor, frontRightMotor;
    private CRServo rack, intake, extension, latch;
    private Servo wrist;

    // controller state values
    double[] values = {
            0,  //0 Left Stick x
            0,  //1 Right Stick x
            0,  //2 Left Trigger
            0,  //3 Right Trigger
            0,  //4 Left Bumper
            0,  //5 Right Bumper
            0,  //6 A
            0,  //7 B
            0,  //8 X
            0,  //9 Y
            0,  //10 right stick button
            0,  //11 left stick button
            0,  //12 dpad left
            0,  //13 dpad right
            0,  //14 dpad up
            0,  //15 dpad down
            0,  //16 Left Stick y
            0,  //17 Right Stick y
            0,  //18 Start
            0,  //19 Back
    };


    public void runOpMode() throws InterruptedException {
        initialize();

        waitForStart();
        while (opModeIsActive()) {
            loopCode();
        }
    }


    public void initialize() {

        // name drive motors
        rightMotor = hardwareMap.dcMotor.get("right");  // rightMotor named (right)
        rightMotor.setDirection(DcMotor.Direction.REVERSE);  // reverse direction of right motor
        leftMotor = hardwareMap.dcMotor.get("left");   // leftMotor named (left)
        rightMotor.setPower(0);
        leftMotor.setPower(0);

        // name accessory motors
        frontLeftMotor = hardwareMap.dcMotor.get("frontLeft");
        frontRightMotor = hardwareMap.dcMotor.get("frontRight");
        frontLeftMotor.setDirection(DcMotor.Direction.REVERSE);
        frontLeftMotor.setPower(0);
        frontRightMotor.setPower(0);

        // name continuous servos
        rack = hardwareMap.crservo.get("rack");
        intake = hardwareMap.crservo.get("intake");
        extension = hardwareMap.crservo.get("extension");
        latch = hardwareMap.crservo.get("latch");

        // name noncontinuous servos
        wrist = hardwareMap.servo.get("wrist");


    }

    public void updateControllerState() {
        values[0] = gamepad1.left_stick_x;
        values[1] = gamepad1.right_stick_x;
        values[2] = gamepad1.left_trigger;
        values[3] = gamepad1.right_trigger;
        values[4] = convertBoolean(gamepad1.left_bumper);
        values[5] = convertBoolean(gamepad1.right_bumper);
        values[6] = convertBoolean(gamepad1.a);
        values[7] = convertBoolean(gamepad1.b);
        values[8] = convertBoolean(gamepad1.x);
        values[9] = convertBoolean(gamepad1.y);
        values[10] = convertBoolean(gamepad1.right_stick_button);
        values[11] = convertBoolean(gamepad1.left_stick_button);
        values[12] = convertBoolean(gamepad1.dpad_left);
        values[13] = convertBoolean(gamepad1.dpad_right);
        values[14] = convertBoolean(gamepad1.dpad_up);
        values[15] = convertBoolean(gamepad1.dpad_down);
        values[16] = gamepad1.left_stick_y;
        values[17] = gamepad1.right_stick_y;
    }

    // Converts booleans to floats (true = 1, false = 0)
    public double convertBoolean(boolean x){
        if(x)
            return 1;
        else
            return 0;
    }
    //controls are set here and algorithms for those controls
    public void setRobotState() {

        // Drive Motor Controls
        // Prep for setting motor powers (left, right)
        double left = 0;
        double right = 0;
        // if turning right
        if (values[0] > 0.1) {
            // if right trigger pressed then subtract turning ratio from adjacent side
            if (values[3] > 0.5) {
                right = values[3] - Math.abs(values[0]);
                left = values[3];
            } else
                // if left trigger pressed
                if (values[2] > 0.1) {
                    right = -values[2] + Math.abs(values[0]);
                    left = -values[2];
                } else {
                // if turning in place
                    left = Math.abs(values[0]);
                    right = -Math.abs(values[0]);
                }
        }
        // if turning left
        if (values[0] < -0.1) {
            // if right trigger pressed then subtract turning ratio from adjacent side
            if (values[3] > 0.1) {
                left = values[3] - Math.abs(values[0]);
                right = values[3];
            } else
                // if left trigger pressed
                if (values[2] > 0.1) {
                left = -values[2] + Math.abs(values[0]);
                right = -values[2];
            } else {
                // if turning in place
                    right = Math.abs(values[0]);
                    left = -Math.abs(values[0]);
                    }
            }
            // if not turning
            if ((values[0] < 0.1) && (values[0] > -.1)) {
                // if pressing both triggers
                if ((values[2] > 0.1) && (values[3] > 0.1)) {
                    right = values[3] - values[2];
                    left = values[3] - values[2];
                }
                // if pressing left trigger
                if (values[2] > 0.1) {
                    right = -values[2];
                    left = -values[2];
                }
                // if pressing right trigger
                if (values[3] > 0.1) {
                    right = values[3];
                    left = values[3];
                }
            }
        // Set motor powers according to current state of joysticks and triggers
        leftMotor.setPower(left);
        rightMotor.setPower(right);



        // Rack controls with values[4] /LB values[5] /RB
        // hold to move rack upwards
        if (values[4] == 1 && rack.getPower() != 1) {  // left bumper
            rack.setPower(1);
        }
        // hold to move rack downwards
        if (values[5] == 1 && rack.getPower() != 0) {  // right bumper
            rack.setPower(0);
        }
        // idle to stop rack motion
        if ((values[4] == 0) && (values[5] == 0)) {
            rack.setPower(.49);
        }



        // Intake Controls values[6] /A values[7] /B
        // hold to take in objects
        if (values[6] == 1 && intake.getPower() != 1) {
            intake.setPower(1);
        }
        // hold to eject objects
        if (values[7] == 1 && intake.getPower() != 0) {
            intake.setPower(0);
        }
        // do nothing when neither button is held
        if (values[6] == 0 && values[7] == 0) {
            intake.setPower(.5);
        }



        // Extension Controls values[16] /LeftStickY
        // variables used
            double extensionIdle = .5;
            double extensionSpeed = extensionIdle;
        // up to extend forwards
            if (values[16] > .8 && extension.getPower() != values[16]) {
                extensionSpeed = extensionIdle * Math.abs(values[16]) + extensionIdle;
                extension.setPower(extensionSpeed);
            }
        // down to retract
            if (values[16] < -.8 && extension.getPower() != values[16]) {
                extensionSpeed = extensionIdle * Math.abs(values[16]);
                extension.setPower(extensionSpeed);
            }
        // no extension or retraction uses "extensionIdle" variable
            if (-.8 <= values[16] && values[16] <= .8) {
                extension.setPower(extensionIdle);
            }



        // Latch Controls values[18} /Start values[19] /Back
        // hold insert hook
        if (values[18] == 1 && latch.getPower() != 1) {
            latch.setPower(1);
        }
        // hold to retract hook
        if (values[19] == 1 && (latch.getPower() != 0)) {
            latch.setPower(0);
        }
        // do nothing when neither button is held
        if (values[18] == 0 && values[19] == 0) {
            latch.setPower(.5);
        }



        // Wrist Controls values[17] /RightStickY
        // used variables
        double wristPos = wrist.getPosition();
        double wristAccel = 0;
        // move upwards
        if (values[17] > .1 && (Math.abs(values[1]) < .3)) {
            // if it will exceed its range of motion
            if ((wrist.getPosition() + wristAccel) >= 1) {
                wristPos = 1;
            } else {
                // set acceleration to 10% of the position of the joystick
                wristAccel = values[17] * .1;
            }
        }
        // move downwards
        if (values[17] < -.1 && (Math.abs(values[1]) < .3)) {
            // if it will exceed its range of motion
            if ((wrist.getPosition() - wristAccel) <= 0) {
                wristPos = 0;
            } else {
                // set acceleration to 10% of the position of the joystick
                wristAccel = values[17] * (-.1);
            }
        }
        // centered joystick
        if(values[17] >= -.1 && values[17] <= .1) {
            wristAccel = 0;
        }
        // set position and reset acceleration value
        if (wristAccel != 0) {
            wristPos = wristPos + wristAccel;
            wrist.setPosition(wristPos);
            wristAccel = 0;
        }



        // Drawbridge controls values[14] /DpadUp values[15] /DpadDown
        // variables used
        double liftSpeed = .5;
        // Lift Drawer Slides
        if (values[14] == 1) {
            frontLeftMotor.setPower(liftSpeed);
            frontRightMotor.setPower(liftSpeed);
        }
        // Lower Drawer Slides
        if (values[15] == 1) {
            frontLeftMotor.setPower(-liftSpeed);
            frontRightMotor.setPower(-liftSpeed);
        }
        // Hold Slides Still
        if (values[14] == 0 && values[15] == 0) {
            frontLeftMotor.setPower(0);
            frontRightMotor.setPower(0);
        }
    }


    public void loopCode() {
        updateControllerState();
        setRobotState();
    }
}
